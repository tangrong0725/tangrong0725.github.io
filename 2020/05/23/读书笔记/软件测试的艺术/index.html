<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		读书笔记/软件测试的艺术 | 
	 
	Hexo
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	
  

	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">


	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">Hexo</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
		
		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/wujun234" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="search...">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										自动化测试
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/python+appium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/">
										python+appium自动化测试总结
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										计算机网络
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										4_网络层
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4_%E7%BD%91%E7%BB%9C%E5%B1%82/4.1%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1/">
										4.1网络层提供的两种服务
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4_%E7%BD%91%E7%BB%9C%E5%B1%82/4.2%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP/">
										4.2网际协议IP
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4_%E7%BD%91%E7%BB%9C%E5%B1%82/4.3%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91/">
										4.3划分子网和构造超网
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4_%E7%BD%91%E7%BB%9C%E5%B1%82/4.4%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP/">
										4.4网际控制报文协议ICMP
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4_%E7%BD%91%E7%BB%9C%E5%B1%82/4.5%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/">
										4.5因特网的路由选择协议
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										读书笔记
									</a>
									
							<ul>
								<li class="file active">
									<a href="/2020/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF/">
										软件测试的艺术
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										软件测试基础
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/">
										测试基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/06/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95V2.0/">
										软件测试V2.0
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/06/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/">
										面试问答
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	软件测试的艺术
</h1>
<div class="article-meta">
	
	<span>Gakki0725</span>
	<span>2020-05-23 14:15:15</span>
    
		<div id="article-categories">
            
		</div>
    
</div>

<div id="article-content">
	<h2 id="1-一个自我评价测试"><a href="#1-一个自我评价测试" class="headerlink" title="1. 一个自我评价测试"></a>1. 一个自我评价测试</h2><ul>
<li>所谓软件测试，就是一个过程或一系列过程．用来确认计算机代码完成了其应该完成的功能不执行其不该有的操作。软件应当是可预测且稳定的，不会给用户带 来意外惊奇。</li>
</ul>
<h2 id="2-软件测试的心理学和经济学"><a href="#2-软件测试的心理学和经济学" class="headerlink" title="2. 软件测试的心理学和经济学"></a>2. 软件测试的心理学和经济学</h2><h3 id="2-1-软件测试的心理学"><a href="#2-1-软件测试的心理学" class="headerlink" title="2.1 软件测试的心理学"></a>2.1 软件测试的心理学</h3><ul>
<li>对于测试，更为合适的定义应该是：“测试是为发现错误而执行程序的过程” 。 </li>
</ul>
<h3 id="2-3-软件测试的原则"><a href="#2-3-软件测试的原则" class="headerlink" title="2.3 软件测试的原则"></a>2.3 软件测试的原则</h3><ul>
<li><p>软件测试的重要原则：</p>
<ol>
<li>测试用例中一个必需部分是对预期输出或结果进行定义</li>
<li>程序员应避免测试自己编写的程序 </li>
<li>编写软件的组织不应当测试自已编写的软件 </li>
<li>应当彻底检查每个测试的执行结果 </li>
<li>测试用例的编写不仅应当根据有效和预料到的输入情况，而且也应当根据无效 和未预料到的输入情况 </li>
<li>检查程序是否“未做其应该做的”仅是测试的一半，测试的另一半是检查程是 否“做了其不应该做的” </li>
<li>应避免测试用例用后即弃，除非软件本身就是个一次性的软件 </li>
<li>计划测试工作时不应默许假定不会发现错误 </li>
<li>程序某部分存在更多错误的可能性，与该部分已发现错误的数量成正比 </li>
<li>软件测试是一项极富创造性，极具智力的挑战性的工作 </li>
</ol>
</li>
<li><p>没有期望，也就没有所谓的意外。 </p>
</li>
<li><p>错误总是倾向于聚集存在。</p>
</li>
</ul>
<h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><ul>
<li>在阅读本书接下来的内容时，请牢记以下三个重要的测试原则：<ul>
<li>软件测试是为发现错误而执行程序的过程。 </li>
<li>一个好的测试用例具有较高的发现某个尚未发现的错误的可能性。 </li>
<li>一个成功的测试用例能够发现某个尚未发现的错误。 </li>
</ul>
</li>
</ul>
<h2 id="3-代码检查、走查与评审"><a href="#3-代码检查、走查与评审" class="headerlink" title="3. 代码检查、走查与评审"></a>3. 代码检查、走查与评审</h2><h3 id="3-1-检查与走查"><a href="#3-1-检查与走查" class="headerlink" title="3.1 检查与走查"></a>3.1 检查与走查</h3><ul>
<li>代码走查的另一个优点在于，一旦发现错误，通常就能在代码中对其进行精确定位，这就降低了调试（错误修正）的成本。</li>
</ul>
<h3 id="3-2-代码检查"><a href="#3-2-代码检查" class="headerlink" title="3.2 代码检查"></a>3.2 代码检查</h3><ul>
<li>代码检查的目标是发现程序中的错误，从而改进软件的质量。</li>
</ul>
<h3 id="3-3-用于代码检查的错误列表"><a href="#3-3-用于代码检查的错误列表" class="headerlink" title="3.3 用于代码检查的错误列表"></a>3.3 用于代码检查的错误列表</h3><ul>
<li><p>用于代码检查的错误列表 </p>
<ul>
<li><p>数据引用错误 </p>
</li>
<li><p>数据声明错误 </p>
</li>
<li><p>运算错误 </p>
</li>
<li><p>比较错误</p>
</li>
<li><p>控制流程错误 </p>
</li>
<li><p>接口错误 </p>
</li>
<li><p>输入/输出错误 </p>
</li>
<li><p>其他检查</p>
<p><img src="/2020/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF/1.png" alt></p>
<p><img src="/2020/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF/2.png" alt></p>
<p><img src="/2020/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF/3.png" alt></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-7小结"><a href="#3-7小结" class="headerlink" title="3.7小结"></a>3.7小结</h3><ul>
<li>大多数的软件项目都应使用到以下的人工测试方法： <ul>
<li>利用错误列表进行代码检查。 </li>
<li>小组代码走查。 </li>
<li>桌面检查。 </li>
<li>同行评审。</li>
</ul>
</li>
</ul>
<h2 id="4-测试用例的设计"><a href="#4-测试用例的设计" class="headerlink" title="4. 测试用例的设计"></a>4. 测试用例的设计</h2><ul>
<li><p>测试用例的设计如此重要，原因在于完全的测试是不可能的，对任何程序的测试必定是不完全的。</p>
</li>
<li><p>由于时间和成本的约束，软件测试的关键问题是： </p>
<ul>
<li>在所有可能的测试用例中，哪个子集有可能发现多的错误？ </li>
</ul>
</li>
<li><p>黑盒测试</p>
<ul>
<li>等价类划分 </li>
<li>边界值分析 </li>
<li>因果图分析 </li>
<li>错误测试 </li>
</ul>
</li>
<li><p>白盒测试 </p>
<ul>
<li>语句覆盖 </li>
<li>判定覆盖 </li>
<li>条件覆盖 </li>
<li>判定/条件覆盖  </li>
<li>多重条件覆盖 </li>
</ul>
</li>
</ul>
<h3 id="4-3-测试策略"><a href="#4-3-测试策略" class="headerlink" title="4.3 测试策略"></a>4.3 测试策略</h3><ul>
<li>一组合理的策略如：<ol>
<li>如果规格说明中包含输入条件组合的情况，应首先使用因果图分析方法。 </li>
<li>在任何情况下都应使用边界值分析方法。应记住，这是对输入和输出边界进行的分析。边界值分析可以产生一系列补充的测试条件，但是，也正如“因果图分析”一节所述，多数甚至全部条件都可以被整合到因果图分析 中。 </li>
<li>应为输入和输出确定有效和无效等价类，在必要情况下对上面确认的测试 用例进行补充。</li>
<li>使用错误猜测技术增加更多的测试用例。 </li>
<li>针对上述测试用例集检查程序的逻辑结构。应使用判定覆盖、条件覆盖、 判定/条件覆盖或多重条件覆盖准则（后的一个为完整）。如果覆盖准则未能被前四个步骤中确定的测试用例所满足，并且满足准则也并非不可能（由于程序的性质限制，某些条件的组合也许是不可能实现的），那么增 加足够数量的测试用例，以使覆盖准则得到满足。 </li>
</ol>
<ul>
<li>再一次声明，使用上述策略并不能保证可以发现所有的错误，但实践证明这是一个合理的折中方案。同时，它也代表了客观的艰巨工作量，虽然没人说软件测试是一件容易的事。</li>
</ul>
</li>
</ul>
<h2 id="5-模块-单元-测试"><a href="#5-模块-单元-测试" class="headerlink" title="5. 模块(单元)测试"></a>5. 模块(单元)测试</h2><ul>
<li><p>模块测试（或单元测试）是对程序中的单个子程序、子程序或过程进行测试的过程，也就是说，一开始并不是对整个程序进行测试，而是首先将注意力集中在对构成程序的较小模块的测试上面。</p>
</li>
<li><p>模块测试的目的是将模块的功能与定义模块的功能规格说明或接口规格说明进行比较。</p>
</li>
</ul>
<h3 id="5-1-测试用例模块"><a href="#5-1-测试用例模块" class="headerlink" title="5.1 测试用例模块"></a>5.1 测试用例模块</h3><ul>
<li>因此，模块测试的测试用例的设计过程如下：使用一种或多种白盒测试方法分析模块的逻辑结构，然后使用黑盒测试方法对照模块的规格说明以补充测试用例。</li>
</ul>
<h3 id="5-2-增量测试"><a href="#5-2-增量测试" class="headerlink" title="5.2 增量测试"></a>5.2 增量测试</h3><ul>
<li><p>测试单独的模块需要一个特殊的驱动模块（drive module）和一个或多个桩模块 （stub module）。举例来说，测试模块 B，首先要设计测试用例，然后将测试用例作为输入参数由驱动模块传递给模块 B。驱动模块是人们编写的一个小模块，用来将测试用例驱动或传输到被测模块中（也可以用测试工具替代）。驱动模块还必须向 测试人员显示模块 B 的结果。此外，由于模块 B 调用了模块 E，所以还必须使用一个额外的组件，该组件在模块 B 调用模块 E 时接受模块 B 的控制指令。这就由桩 模块来完成它是一个被命名为“E”的特殊模块，用来模拟模块 E 的功能。当所有 6 个模块的模块测试都完成之后，就将这些模块组装成完整的程序。</p>
</li>
<li><p>增量测试：不同于独立地测试每个模块，增量测试首先 将下一个要测试的模块组装到前面已经测试过的模块集合中去。 </p>
</li>
</ul>
<h3 id="5-3-自顶向下的测试"><a href="#5-3-自顶向下的测试" class="headerlink" title="5.3 自顶向下的测试"></a>5.3 自顶向下的测试</h3><ul>
<li><p>自顶向下的测试是从程序的顶部或初始模块开始。测试开始之后，挑选哪一个后续模块进行增量测试没有惟一正确的方法：惟一的原则是：要成为合乎条件的下 一个模块，至少一个该模块的从属模块（调用它的模块）事先经过了测试。</p>
<p>  <img src="/2020/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF/4.png" alt></p>
</li>
</ul>
<h3 id="5-4-执行测试"><a href="#5-4-执行测试" class="headerlink" title="5.4 执行测试"></a>5.4 执行测试</h3><ul>
<li><p>程序员不应测试自己编写的模块，而应交换模块进行测试。编写调用模块的程序员始终是测试被调用模块的佳候选人。</p>
</li>
<li><p>记住模块测试的目的不是证明模块能够正确地运行， 而是证明模块中存在着错误。 </p>
</li>
</ul>
<h3 id="6-1-功能测试"><a href="#6-1-功能测试" class="headerlink" title="6.1 功能测试"></a>6.1 功能测试</h3><ul>
<li><p>在进行功能测试时，需要对规格说明进行分析以获取测试用例集。</p>
</li>
<li><p>最后，应始终牢记功能测试的目的是为了暴露程序的错误以及与规格说明不一致之处，而不是为了证明程序符合其外部规格说明。 </p>
</li>
<li><p>系统测试有着特定的目的：将系统或程序与其初始目标进行比较。给定这个目标之 后，隐含两方面的含义： </p>
<ol>
<li>系统测试并不局限于系统。如果产品是一个程序，那么系统测试就是一个试图说明程序作为一个整体是如何不满足其目标的过程。</li>
<li>根据定义，如果产品没有一组书面的、可度量的目标，系统测试也就无法进行。 </li>
</ol>
</li>
<li><p>以下是从其他角度来审视上述文档的形式： </p>
<ol>
<li>需求规格说明定义了为什么要开发程序。 </li>
<li>目标定义了程序要做什么，以及应做得怎样。</li>
<li>外部规格说明定义了程序对用户的准确表现。 </li>
<li>与后续阶段相关的文档越来越详细地规定了程序是如何建立起来的。 </li>
</ol>
</li>
<li><p>通过分析目标文档来设计系统测试，分析用户文档来阐明测试用例。</p>
</li>
<li><p>15种系统测试用例：</p>
<ol>
<li><p>能力测试：明显的系统测试类型是判断目标文档提及的每一项能力（或功能，为了避免与功能测试发生混淆而不使用“功能”一词）是否都确实已经实现。</p>
</li>
<li><p>容量测试：是使程序经受大容量数据的检验。</p>
</li>
<li><p>强度测试：使程序承受高负载或强度的检验。这不应和容量测试发生混淆；所谓高强度是指在很短的时间间隔内达到的数据或操作的数量峰值。类似的情况是测试一名打字员。容量测试是判断打字员能否处理大篇幅的稿子，而强度测试则是判断打字员能否达到每分钟 50 个单词的速度。 </p>
</li>
<li><p>易用性测试：系统测试的另一个重要类型是试图发现人为因素或易用性的问题。</p>
<ol>
<li>如：<ol>
<li>界面设计是否合理，用户使用是否会存在疑问？</li>
<li>程序的输出是否有意义、不模糊且没有计算机的杂乱信息？</li>
<li>错误提示是否直接明了？</li>
<li>整体的界面在语法、语义、风格等方面是否统一？</li>
<li>在极其重要的环境里，是否有足够的荣誉信息？【付钱的时候是否输密码】</li>
<li>系统上是否存在过多或不太可能用到的选项？</li>
<li>对于所有的输入，系统是否返回了某些类型的即使确认信息？【界面加载的时候有转菊花，点击输入框的时候，输入框会有所变化】</li>
<li>程序是否易于使用？【返回主界面是否清楚】</li>
</ol>
</li>
</ol>
</li>
<li><p>安全性测试：安全性测试是设计测试用例来突破程序安全检查的过程。。设计此种测试用例的方法之一是研究类似系统中已知的安全问题，然后生成测试用例，尽量暴露被测系统存在相似问题。</p>
</li>
<li><p>性能测试：为在特定负载和配置环境下程序的响应时间和吞吐率。再一次强调，由于系统测试的目的是为了证明程序不能实现其目标，因此应设计测试用例来说明程序不能满足其性能目标。 </p>
<p><img src="/2020/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF/5.png" alt></p>
<p><img src="/2020/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF/6.png" alt></p>
<p><img src="/2020/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF/7.png" alt></p>
<ol start="7">
<li>存储测试：软件偶尔会有存储目标，举例来说，可能描述了程序使用的内存和辅存的容量，以及临时文件或溢出文件的大小。应设计测试用例来证明这些存储目标 没有得到满足。</li>
<li>配置测试：如今的很多软件都设计成可运行在多种操作系统下，因此如果测试此类程序， 应该在该程序面向的所有操作系统环境中对其进行测试。对设计在 Web 浏览器里运 行的程序，需要特别的注意，因为 Web 浏览器的种类繁多，并不是所有浏览器都按 同样方式运行。除此之外，即使是同一种 Web 浏览器，在不同的操作系统之下，运 行方式也会不同。 </li>
<li>兼容性/配置/转换测试：在针对这些目标测试程序时、测试用例的目的是证明兼容性目标未被满。在将数据从一个系统转移到另一个系统时，应尽力发现错误。足，转换过程并未生效。</li>
</ol>
</li>
<li><p>安装测试：其目的不是为了发现软件中的错误，而是为了发现在安装过程中出现的错误。 </p>
<ul>
<li>在安装软件系统期间会发生很多事件。作为示例的简短列表包括了下列事件： <ol>
<li>用户必须选择大量的选项。 </li>
<li>必须分配并加载文件和库。 </li>
<li>必须进行有效的硬件配置。 </li>
<li>软件可能要求网络联通，以便与其他软件连接。 </li>
</ol>
</li>
</ul>
</li>
<li><p>可靠性测试：</p>
</li>
<li><p>可恢复性测试：</p>
</li>
<li><p>适用性测试：</p>
</li>
<li><p>文档测试：一旦设计完成某个具体的测试情况，应该使用文档作为编写实际测试用例的指南。同时， 用户文档应成为审查的对象，检查其正确性和清晰性。</p>
</li>
<li><p>过程测试：</p>
</li>
<li><p>系统测试的执行</p>
</li>
<li><p>验收测试：将程序与其初的需求及终用户当前的需要进行比较的过程。验收测试好的方法是设计测试用例，尽力证明程序没有满足合同要求。</p>
</li>
</ol>
</li>
<li><p>一个良好 的测试计划应包括： </p>
<ol>
<li>目标。必须定义每个测试阶段的目标。 </li>
<li>结束准则。必须制定准则以规定每个测试阶段何时可以结束。</li>
<li>进度。每个阶段都须有时间表。应指出何时设计、编写和执行测试用例，某些软件技术，如极限编程要求在程序编码开始 之前就设计测试用例和单元测试。</li>
<li>责任。对于每一个阶段，应当确定谁来设计、编写和验证测试用例，谁来修改发现的软件错误。由于在大型项目中讨论特定的测试结果是否代表错 误时，有可能出现争端，因此还需要确定一名仲裁者。</li>
<li>测试用例库及标准。在大型项目中，用于确定、编写以及存储测试用例的 系统方法是必须的。 </li>
<li>工具。必须确定需要使用的测试工具，包括计划由谁来开发或采购、如何 使用工具以及何时需要使用工具。</li>
<li>计算机时间。计划每个测试阶段所需的计算机时间，包括用来编译应用程序的服务器（如果需要的话）、用来进行安装测试所需的桌面计算机、用来 运行基于 web 应用程序的 web 服务器、联网的设备（如果需要的话）等等。</li>
<li>硬件配置。如果需要特别的硬件配置或设备，则需要一份计划来描述该需 求，该如何满足需求以及何时需要满足。 </li>
<li>集成。测试计划的一部分是定义程序如何组装在一起的方法（例如自顶向下的增量测试）。一个系统如果包含大的子系统或程序，可按增量的方式组装在一起，例如可以使用自顶向下或自底向上的方法，但是这些构造块是程序或子系统，而不是模块。如果是这种情况，就需要一个系统集成计划。系统集成计划规定了系统集成的顺序、系统每个版本的功能以及编写“脚 手架”代码以模拟不存在的部件的职责分工。</li>
<li>跟踪步骤。必须跟踪测试进行中的方方面面，包括对错误易发模块的定位， 以及有关进度、资源和结束准则的进展估计。  </li>
<li>调试步骤。必须制定上报已发现错误、跟踪错误修改进程以及将修改部分加入系统中去的机制。调试计划中还应包括进度、责任分工、工具以及计 算机时间/资源等。</li>
<li>回归测试。回归测试在对程序作了功能改进或进行了修改之后进行，其目的是判断程序的改动是否引起了程序其他方面的退步。回归测试通常重新执行测试用例中的某个子集。回归测试很重要，因为对程序的改动和对错误的纠正要比原来的程序代码更容易出错（与报纸排版错误很相似，这些错误通常由于后所做的编辑改动而引起的，而不是修改先前版本而引起的）。回归测试计划规定了测试人员、测试方法和测试时间，它也是必须的。</li>
</ol>
</li>
</ul>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="暴力法调试"><a href="#暴力法调试" class="headerlink" title="暴力法调试"></a>暴力法调试</h3><ul>
<li><p>暴力调试方法可至少被划分为三种类型： </p>
<ol>
<li>利用内存信息输出来调试。</li>
<li>根据一般的“在程序中插入打印语句”建议来调试。 </li>
<li>使用自动化的调试工具进行调试。 </li>
</ol>
</li>
<li><p>因此，我们建议仅在下列情况下使用暴力调试方法：（l）其他的方法都失败了：（2）作为我们下面将会讨论的思考过程的补充，而不是替代方法。</p>
</li>
</ul>
<h3 id="归纳法调试"><a href="#归纳法调试" class="headerlink" title="归纳法调试"></a>归纳法调试</h3><p>《图片》</p>
<h3 id="演绎法调试"><a href="#演绎法调试" class="headerlink" title="演绎法调试"></a>演绎法调试</h3><p>《图片》</p>
<h3 id="回溯法调试"><a href="#回溯法调试" class="headerlink" title="回溯法调试"></a>回溯法调试</h3><ul>
<li>在小型程序中定位错误的一种有效方法是沿着程序的逻辑结构回溯不正确的结果，直到找出程序逻辑出错的位置。换</li>
</ul>
<h3 id="测试法调试"><a href="#测试法调试" class="headerlink" title="测试法调试"></a>测试法调试</h3><ul>
<li>供测试的测试用例，其目的是暴露出以前尚未发现的错误．供调试的测试用例，其目的是提供有用的信息，供定位某个被怀疑的错误之用。</li>
</ul>
<h3 id="定位错误的原则"><a href="#定位错误的原则" class="headerlink" title="定位错误的原则"></a>定位错误的原则</h3><ul>
<li>动脑筋</li>
<li>如果遇到了僵局，就留到稍后解决</li>
<li>如果遇到了困境，就把问题描述给其他人听 </li>
<li>仅将测试工具作为第二种手段</li>
<li>避免使用试验法——仅将其作为后的手段</li>
</ul>
<h3 id="修改错误的技术"><a href="#修改错误的技术" class="headerlink" title="修改错误的技术"></a>修改错误的技术</h3><ul>
<li>存在一个缺陷的地方，很有可能还存在其他缺陷</li>
<li>应纠正错误本身，而不仅是其症状</li>
<li>正确纠正错误的可能性并非 100%</li>
<li>正确修改错误的可能性随着程序规模的增加而降低</li>
<li>应意识改正错误会引入新错误的可能性</li>
<li>修改错误的过程也是临时回到设计阶段的过程</li>
<li>应修改源代码，而不是目标代码</li>
</ul>
<h3 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h3><ul>
<li><p>详细的错误分析会包括如下内容：</p>
<ul>
<li>错误出现在什么地方？</li>
<li>谁制造了这个错误？</li>
<li>哪些做得不正确？</li>
<li>如何避免该错误的出现？</li>
<li>为什么错误没有早些发现？</li>
<li>该如何更早地发现错误？</li>
</ul>
</li>
<li><p>再一次申明，分析的过程是很艰难的，但是找到的答案为改进后续的编程实践提供极其宝贵的价值。值得警惕的是，绝大多数的程序员和编程机构都尚未使用这种方法。</p>
</li>
</ul>
<h2 id="极限测试"><a href="#极限测试" class="headerlink" title="极限测试"></a>极限测试</h2><h3 id="极限编程基础"><a href="#极限编程基础" class="headerlink" title="极限编程基础"></a>极限编程基础</h3><ul>
<li><p>XP（XP，Extreme Programming）的策划阶段将重点放在收集应用程序需求，而不是设计程序上。</p>
</li>
<li><p>XP 开发模型用 12 个核心实践来驱动该过程。简单来 说．这12个核心的XP实践可以归纳为4个概念：</p>
<ol>
<li>聆听客户和其他程序员的谈话。</li>
<li>与客户合作，开发应用程序的规格说明和测试用例。</li>
<li>结对编码。</li>
<li>测试代码库。</li>
</ol>
</li>
</ul>
<p>《图片》</p>
<h3 id="极限测试：概念"><a href="#极限测试：概念" class="headerlink" title="极限测试：概念"></a>极限测试：概念</h3><ul>
<li>极限测试主要由两种类型的测试组成：单元测试和 验收测试。</li>
</ul>
<h3 id="极限单元测试"><a href="#极限单元测试" class="headerlink" title="极限单元测试"></a>极限单元测试</h3><ul>
<li>单元测试是极限测试中采用的主要测试方法，它具有两个简单规则：所有代码模块在编码开始之前必须设计好单元测试用例，在产品发布之前须通过单元测试。</li>
</ul>
<h3 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h3><ul>
<li>验收测试的目的是判断应用程序是否满足如功能性和易用性等其他需求。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>极限编程中的测试被称为“极限测试”。极限测试的重点在于单元测试和验收测试。一旦代码库发生变更，就需要进行单元测试。在重要的发布结点，由客户来执行验收测试。 </li>
</ul>

</div>


    <div class="post-guide">
        <div class="item left">
            
              <a href="/2020/06/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95V2.0/">
                  <i class="fa fa-angle-left" aria-hidden="true"></i>
                  软件测试V2.0
              </a>
            
        </div>
        <div class="item right">
            
              <a href="/2020/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4_%E7%BD%91%E7%BB%9C%E5%B1%82/4.5%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/">
                4_网络层
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>



	<div id="vcomments"></div>


<script>
	
		// 评论
		new Valine({
			av: AV,
			el: '#vcomments',
			notify: false,
			verify: false,
			path: window.location.pathname,
			appId: '',
			appKey: '',
			placeholder: '请输入评论',
			avatar: 'retro',
			recordIP: false
		})
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">Gakki0725</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>