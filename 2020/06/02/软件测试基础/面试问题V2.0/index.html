<!DOCTYPE html>
<html lang="en">

<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
	
	<!-- title -->
	
	<title>
	
		面试问题V2.0 | 
	 
	Hexo
	</title>
	
	<!-- keywords,description -->
	 

	<!-- favicon -->
	
	<link rel="shortcut icon" href="/favicon.ico">
	
  

	
<link rel="stylesheet" href="/css/main.css">

	
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css">

	
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/darcula.min.css">


	
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

	
<script src="https://cdn.jsdelivr.net/npm/jquery-pjax@2.0.1/jquery.pjax.min.js"></script>

	
<script src="/js/main.js"></script>

	
		
<script src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>

		
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

	
	
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
	<header id="header">
    <a id="title" href="/" class="logo">Hexo</a>

	<ul id="menu">
		<li class="menu-item">
			<a href="/about" class="menu-item-link">ABOUT</a>
		</li>
		
		<li class="menu-item">
			<a href="https://github.com/wujun234/uid-generator-spring-boot-starter" class="menu-item-link" target="_blank">
				UidGenerator
			</a>
		</li>
		<li class="menu-item">
			<a href="https://github.com/wujun234" class="menu-item-link" target="_blank">
				<i class="fa fa-github fa-2x"></i>
			</a>
		</li>
	</ul>
</header>

	
<div id="sidebar">
	<button id="sidebar-toggle" class="toggle" ><i class="fa fa-arrow-right " aria-hidden="true"></i></button>
	
	<div id="site-toc">
		<input id="search-input" class="search-input" type="text" placeholder="search...">
		<div id="tree">
			

			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										自动化测试
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/python+appium%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%80%BB%E7%BB%93/">
										python+appium自动化测试总结
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										计算机网络
									</a>
									
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										4_网络层
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4_%E7%BD%91%E7%BB%9C%E5%B1%82/4.1%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1/">
										4.1网络层提供的两种服务
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4_%E7%BD%91%E7%BB%9C%E5%B1%82/4.2%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AEIP/">
										4.2网际协议IP
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4_%E7%BD%91%E7%BB%9C%E5%B1%82/4.3%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91/">
										4.3划分子网和构造超网
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4_%E7%BD%91%E7%BB%9C%E5%B1%82/4.4%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AEICMP/">
										4.4网际控制报文协议ICMP
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4_%E7%BD%91%E7%BB%9C%E5%B1%82/4.5%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE/">
										4.5因特网的路由选择协议
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										读书笔记
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF/">
										软件测试的艺术
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
							<ul>
								<li class="directory">
									<a href="#" class="directory">
										<i class="fa fa-plus-square-o"></i>
										软件测试基础
									</a>
									
							<ul>
								<li class="file">
									<a href="/2020/05/23/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/">
										测试基础
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/06/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95V2.0/">
										软件测试V2.0
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file">
									<a href="/2020/06/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/">
										面试问答
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
							<ul>
								<li class="file active">
									<a href="/2020/06/02/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98V2.0/">
										面试问题V2.0
									</a>
								</li>
								<div class="article-toc" style="display: none;"></div>
							</ul>
			
								</li>
								
							</ul>
			
		</div>
	</div>
</div>

	<!-- 引入正文 -->
	<div id="content">
		<h1 id="article-title">

	面试问题V2.0
</h1>
<div class="article-meta">
	
	<span>Gakki0725</span>
	<span>2020-06-02 20:50:33</span>
    
		<div id="article-categories">
            
		</div>
    
</div>

<div id="article-content">
	<h3 id="session与cookie的区别？"><a href="#session与cookie的区别？" class="headerlink" title="session与cookie的区别？"></a>session与cookie的区别？</h3><pre><code>* cookie数据存放在客户的浏览器上，session数据放在服务器上。
* cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。
* session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。
* 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</code></pre><h3 id="session与token的区别？"><a href="#session与token的区别？" class="headerlink" title="session与token的区别？"></a>session与token的区别？</h3><pre><code>* Http是一个无状态协议，如果客户端需要继续操作每次都需要重新传递信息。所以需要客户端登录后由服务端授予一个标识，下次客户端如果带上这个标识则服务端会识别出这个用户。这个标识一般使用Session或Token。
* 作为身份认证，token安全行比session好；
* Session是存储在服务端的会话，登录成功后，客户端在cookies拥有一个sessionId。当访问的时候cookies将id带过去，服务端通过id，找到会话信息。
* Token是无状态的一串令牌，当用户登录后返回的token字符串，字符串包含一定的用户信息。当token字符串未失效时，使用token获取用户登录信息。
* token 也称作令牌，由uid+time+sign[+固定参数]
* 使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</code></pre><ul>
<li>总结：<ul>
<li>session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie</li>
<li>cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。</li>
<li>token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户。需要开发者手动添加。</li>
</ul>
</li>
<li>“只要关闭浏览器 ，session就消失了？”<ul>
<li>不对。对session来说，除非程序通知服务器删除一个session，否则服务器会一直保留，程序一般都是在用户做log off的时候发个指令去删除session。</li>
<li>然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接服务器时也就无法找到原来的session。如果服务器设置的cookie被保存在硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的session id发送给服务器，则再次打开浏览器仍然能够打开原来的session.</li>
</ul>
</li>
</ul>
<h3 id="post、get区别？"><a href="#post、get区别？" class="headerlink" title="post、get区别？"></a>post、get区别？</h3><pre><code>* get与post没有本质的区别。本质上都是TCP链接，并无差别。
* get可以带request body，post也可以在url放数据。但是不同服务器的处理方式不同。就算你发送get在request body/post的url中放了数据，也不能保证一定能接收到。
* GET和POST有一个重大区别，简单的说：
    * GET产生一个TCP数据包；POST产生两个TCP数据包(注并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次)。
    * 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
    * 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
    * 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</code></pre><h3 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令?"></a>linux命令?</h3><h3 id="数据库命令？"><a href="#数据库命令？" class="headerlink" title="数据库命令？"></a>数据库命令？</h3><h3 id="adb常用命令？"><a href="#adb常用命令？" class="headerlink" title="adb常用命令？"></a>adb常用命令？</h3><pre><code>* adb devices：主要是用于打印当前连接的所有模拟器或者设备。
* adb kill-server：终止 adb 进程。
* adb install：主要用于往 Android 设备 push 应用。
    * adb install [option] &lt;path&gt;
    * 其中的 option 也是比较有讲究的，下面就只说最常用的。
    * adb install test.apk 直接安装应用
    * adb install -r test.apk 替代存在的应用，不会删除应用数据，用于更新应用特别方便。
* adb uninstall：从设备或者模拟器卸载应用。
    * adb uninstall [options] &lt;package&gt;
    * 两种情况，假设我们的应用 APP 包名是 com.example.application
    * adb uninstall com.example.application 直接删除应用和所有数据
    * adb uninstall -k com.example.application 删除应用，但会保留应用数据和缓存数据( -r 覆盖安装，保留数据和缓存文件  -d 解决低版本version问题  -s 安装apk到sd卡)。
* adb logcat：打印日志文件。
    * adb logcat [options] [filter-specs]
    * adb logcat *:V lowest priority, filter to only show Verbose level
    * adb logcat *:D filter to only show Debug level
    * adb logcat *:I filter to only show Info level
    * adb logcat *:W filter to only show Warning level
    * adb logcat *:E filter to only show Error level
    * adb logcat *:F filter to only show Fatal level
    * adb logcat *:S Silent, highest priority, on which nothing is ever printed
* 启动activity
    * adb shell dumpsys window | findstr mCurrentFocus  命令查看当前运行的包名和Activity
* adb version：查看adb版本</code></pre><h3 id="安卓查看日志？"><a href="#安卓查看日志？" class="headerlink" title="安卓查看日志？"></a>安卓查看日志？</h3><h3 id="linux基础命令？"><a href="#linux基础命令？" class="headerlink" title="linux基础命令？"></a>linux基础命令？</h3><h3 id="linux查看日志？"><a href="#linux查看日志？" class="headerlink" title="linux查看日志？"></a>linux查看日志？</h3><pre><code>* 查看日志步骤
    * 下载xshell
    * 新建会话，使用账号密码登录你使用系统的服务器，进行连接。
    * 连接成功后，敲击命令cd /xxx（切换到当前工作命令）；继续敲ls，列出文件下的所有文件，找到当前系统存放的那个文件夹中；继续cd zhgl-server；
    * 将会显示一个logs
    * ls -lrt，显示一下日志有多少条
    * cd logs，进入logs文件夹，ls查询每天的的文件，然后敲命令，，tail -f localhost_access_log.2018-12-11.txt(当前时间)今天的实时日志，操作一下系统，就会报出相应的日志。
* linux查看日志文件内容命令tail、cat、tac、head、echo
    * tail -f test.log：你会看到屏幕不断有内容被打印出来. 这时候中断第一个进程Ctrl-C。
* linux 如何显示一个文件的某几行(中间几行)
    * 从第3000行开始，显示1000行。即显示3000~3999行
    * cat filename | tail -n +3000 | head -n 1000
    * 显示1000行到3000行
    * cat filename| head -n 3000 | tail -n +1000
    * 注意两种方法的顺序
        * 分解：
        * tail -n 1000：显示最后1000行
        * tail -n +1000：从1000行开始显示，显示1000行以后的
        * head -n 1000：显示前面1000行
    * 用sed命令
        * sed -n &#39;5,10p&#39; filename 这样你就可以只查看文件的第5行到第10行。
    * cat mylog.log | tail -n 1000 #输出mylog.log 文件最后一千行
    * cat主要有三大功能：
        *  1.一次显示整个文件。$ cat filename
        *  2.从键盘创建一个文件。$ cat &gt; filename 只能创建新文件,不能编辑已有文件.
        *  3.将几个文件合并为一个文件： $cat file1 file2 &gt; file
    *  tac (反向列示)
    *  tac 是将 cat 反写过来，所以他的功能就跟 cat 相反， cat 是由第一行到最后一行连续显示在萤幕上，而 tac 则是由最后一行到第一行反向在萤幕上显示出来！</code></pre><h3 id="APP专项测试？"><a href="#APP专项测试？" class="headerlink" title="APP专项测试？"></a>APP专项测试？</h3><pre><code>* 主要分为几类：
    * 稳定性
    * 安全性
    * 兼容性
    * 版本升级
    * 流量测试
    * 实际测试总结

* 稳定性测试
    * 稳定性测试是指对应用进行长时间的操作，检测功能是否稳定。一般稳定性测试时间是 N*12小时。项目中稳定测试多采用monkey，进行随机测试。
    * 测试方法：
    * 1、跑monkey
    * adb shell monkey -p packageName -v -v -v --throttle 500 -s 4 --ignore-crashes --ignore-timeouts --ignore-security-exceptions times(次数) |logcat -v time &gt; e:\log\monkeyLog.txt（日志保存路径）
    * 参数：
        * -p ： 指点包名,如果要指定多个包名，需多个-p参数
        * -v ： 指定日志的详细程度，取值1-3，三个 -v 详细程度最高
        * -throttle ： 指定用户操作时的时延，单位毫秒
        * -s ： 指定伪随机数生成器的seed值，取值1-10，当seed相同，产生的事件序列也相同
        * –ignore-crashes ： 指应用程序崩溃，monkey依然发送事件，直到事件数完成
        * –ignore-timeouts： 指应用程序发生ANR，monkey依然发送事件，直到事件数完成
        * –ignore-security-exceptions： 指应用程序发生许可错误，monkey依然发送事件，直到事件数完成
        * |logcat -v time： 给monkey命令的日志加上时间
    * 2、日志解析
        * 稳定性测试是否能通过在于日志，需要把日志里的报错日志搜索出来，开发定位问题。
        * 1）用Notepad++打开日志
        * 2）ctrl + F
        * 3）分析exception日志，定位问题。
* 安全测试
    * 在自己的项目测试中，安全测试就是利用一些安全辅助平台对被测应用进行测试，主要用到两个安全辅助平台：腾讯哈勃分析系统 和 VirusTotal（一个可疑文件分析服务的网站）以及drozer(安全测试工具)。
* 兼容性测试
    * 主要是对app在各类机型上的兼容、适配等情况进行测试，而且用户体验是评价一个产品好坏的重要指标，所有做出来的软件，盈利的软件，最终是交付给用户。所以兼容性测试也是一个很重要的测试项。
    * 兼容性测试常见的便是：
    * 1）移动端设备的版本号测试
    * 2）手机屏幕的分辨率测试
    * 3）新老版本兼容测试（一个app, 一次次迭代，就会有多个版本在市场上被使用，新版本的开发不应该影响到旧版本，尤其是出现一次版本改动比较大，或者重构应用的时候，回归多个老版本是必不可少的测试点，当然并不是要测试到每个点，修改的部分需着重测试，可以和开发沟通了解，了解可能影响的点，有针对性的测试）。
        * 测试点：
        * 1、主要流程能正常运行
        * 2、界面没有错位、重叠，展示不全等不美观问题
        * 3、旧版本可能影响的模块主要功能可以正常运行
        * 版本号：功能正常运行。
        * 分辨率：页面美观，无错位，重叠，展示不全等问题。
* 版本升级
    * 每次版本的迭代都需要测升级，去验证升级之后主要功能是否正常。一般情况下，正常用户升级自己的软件，无异于三种途径：
        * 根据app弹出的升级提示框选择升级
        * 自己到应用商店或者其他渠道下载升级
        * 强制升级
* 流量测试
    * 应用的耗流也是用户的一个重要关注点，一是节省用户的使用成本，二是流量优化能带来响应速度的优化，三是能清楚的知道每个场景需消耗的流量，确认是否有能优化的空间。
    * 测试点：
        * 1、首次启动到全部加载完成耗流（冷启动）
        * 2、非首次启动到全部加载完成耗流（热启动）
        * 3、后台运行耗流
        * 4、运行某个场景消耗的总流量
    * 测试方法：
* 实际项目中的测试项
    * 一个版本的迭代到上线，最终要输出的一个测试通过的报告，才会正式上线。测试报告中应包含了项目团队这一次版本的所有内容。根据我团队的项目（新闻类app），测试报告大体包括：
        1. Release Note (罗列此版本迭代和修改优化的功能点)
        2. 测试用例 （功能点）
        3. 稳定性测试（跑monkey,对日志、内存进行分析）
        4. 内存泄漏 (连续500次的登陆退出) ----（monkeyrunner）写的脚本
        5. 性能测试（内存+CPU）
        6. 兼容性测试 （版本号、分辨率）
        7. 安全测试 （安全网站扫描）
        8. 流量测试 （测试工具统计：emmagee）
        9. 功耗测试 （测试工具统计：emmagee）</code></pre><h3 id="ANR？-书签"><a href="#ANR？-书签" class="headerlink" title="ANR？(书签)"></a>ANR？(书签)</h3><pre><code>* ANR，是“Application Not Responding”的缩写，即“应用程序无响应”。
* 如果应用程序主线程（即UI线程）在超时时间内对输入事件没有处理完毕，或者对特定操作没有执行完毕，就会出现ANR。
* 对于输入事件没有处理完毕产生的ANR，Android会显示一个对话框，提示用户当前应用程序没有响应，用户可以选择继续等待或者关闭这个应用程序（也就是杀掉这个应用程序的进程）。
* 在Android里, App的响应能力是由Activity Manager和Window Manager系统服务来监控的. 通常在如下三种情况下会弹出ANR对话框:
    * 5s内无法响应用户输入事件(例如键盘输入, 触摸屏幕等)
    * BroadcastReceiver在10s内无法结束
    * ServiceTimeout(20s) --小概率类型，Service在特定的时间内无法处理完成
* ANR的处理，一般的处理情况如下：
    * 主线程阻塞：开辟单独的子线程来处理耗时阻塞事务。
    * CPU满负荷, I/O阻塞：I/O阻塞一般来说就是文件读写或数据库操作执行在主线程了, 也可以通过开辟子线程的方式异步执行。
    * 内存不够用：增大VM内存, 使用largeHeap属性, 排查内存泄露等。</code></pre><h3 id="app版本升级的测试点？"><a href="#app版本升级的测试点？" class="headerlink" title="app版本升级的测试点？"></a>app版本升级的测试点？</h3><pre><code>* 主要分文强制更新和非强制更新
* (1)强制更新需要测试的点有：
    * 强制升级是否可以升级成功
    * 升级后数据是否正常
        * 查看老账户升级后是否可以正常使用
        * 查看老账户升级后的老数据是否丢失或异常
        * 检查新功能替换老功能是否按最新的逻辑执行
        * 检查旧版本上去掉或隐藏的功能对新版本有没有影响
    * 强制升级的弹窗是否可以关闭：
        * 检查强制更新窗口有没有其他可以关闭的按钮或功能，比如点击背景阴影弹框消失等。
    * 提示强制更新的提示：
        * 配置升级功能后是否一打开应用就提示升级；多次打开应用是否强制弹框不消失。
* (2)非强制更新的测试点有：
    * 提示框的显示
    * 选择非强制更新时，是否可以选择暂不更新和立即更新；是否可以关闭弹框不显示。
    * 01.选择暂不更新
        * 选择暂不更新：老版本是否可以正常使用；选择暂不更新操作页面不会出现再出现非强制更新的弹框。
        * 选择立即更新：选择立即更新去下载新版本，查看新版本号是否是最新版本；功能是否是最新的，检查点同强制更新的，这里不再赘述了。选择立即更新，下载后没有安装软件，以后还会不会提示。
    * 02.非强制更新弹框的提示频率
        * 提示频率看产品规定的，一般遇到的一天提示一次或固定时间提示一次。因为不是强制更新，可以选择不更新，如果没有打开应用提示一次或者一直提示会对用户体验不友好。
    * 03.查看设置部分的版本更新
        * 一般应用设置部分会有个检测版本功能，非强制更新检查版本更新是否也可以弹出非强制更新的弹框。
    * 04.回归老版本
        * 非强制更新还有工作需要做的就是回归老版本，检查新功能是否出现在老版本上；新老功能替换时，老版本的老功能是否可以正常使用；新用户向老用户发送信息时，会不会提示版本需升级后才能查看（对老版本上新数据的处理）。
    * 05.版本号对比等等
* 总结：强制升级一般用于版本改动较大，业务较重要，功能模块存在风险的情况；非强制更新适用于版本改动不是很大，对业务影响不大，不存在风险问题的。</code></pre><h3 id="怎么去判断是前后端bug？"><a href="#怎么去判断是前后端bug？" class="headerlink" title="怎么去判断是前后端bug？"></a>怎么去判断是前后端bug？</h3><pre><code>1. 首先确定是界面显示问题还是功能问题；
2. 如果是界面问题，如贴图错误，文字错误，样式错误，则需要截图。
3. 如果是功能问题，控制台的问题至少定位到：www的问题还是数据库问题，如果是www问题至少要定位到是前端还是后端问题；如果是数据库问题至少要定位到是服务端接口问题还是中间件问题。
4. 客户端的问题至少定位到：哪个dll模块或者逻辑出的问题
5. 服务端的问题至少定位到：什么接口出的问题，导致数据库哪里不对，
6. &lt;综合来讲就是：抓包&gt;</code></pre><h3 id="fiddle抓包需要做什么？"><a href="#fiddle抓包需要做什么？" class="headerlink" title="fiddle抓包需要做什么？"></a>fiddle抓包需要做什么？</h3><pre><code>1. 把&quot;Allow remote computers to connect&quot;打开，记住监听端口8888；
2. 手机同一局域网下设置代理。电脑IP+端口号；
3. 手机浏览器下输入：IP+端口号下载证书。</code></pre><h3 id="APP与web测试的异同？"><a href="#APP与web测试的异同？" class="headerlink" title="APP与web测试的异同？"></a>APP与web测试的异同？</h3><pre><code>1. 功能测试层面上来讲，两者在流程和功能测试上没有太大区别；
2. 根据两者载体不一样，则区别如下：
    1. 系统结构方面：
        * web项目：B/S架构，基于浏览器的；web测试只要更新了服务器端，客户端就会同步更新；
        * app项目：C/S架构，必须要有客户端；app修改了服务端，则客户端用户所有核心版本都需要进行回归测试一遍。
    2. 性能方面：
        * web项目：需监测响应时间、cpu、内存
        * app项目：除了监听响应时间、CPU、内存外，还需要监控流量、电量等。
    3. 兼容方面:
        * web项目：
            1. 浏览器(火狐、谷歌、IE等)
            2. 操作系统(WIN7、WIN10、linux等)
        * app项目：
            1. 设备系统：IOS(ipad、iPhone)、Android(华为、三星等)
            2. 手机设备可根据手机型号、分辨率不同来。
    4. 相对于web项目，APP有专项测试：
        * 干扰测试：中断、来电、短信、关机、重启等。
        * 弱网测试(模拟2G/3G/4G/WIFI以及丢包情况)；网络切换测试(网络断开后重连、3G切换到4G/wifi等)
        * 安装、更新、卸载
            * 安装：需考虑安装时的中断、弱网、安装后删除安装文件等情况；
            * 卸载：需考虑卸载后是否删除APP相关文件；
            * 更新：分强制更新、非强制更新、增量包更新、断点续传、弱网情况下更新。
    5. 测试工具：
         * 自动化工具：APP一般使用appium，web一般使用selenium；
         * 性能测试工具：APP一般使用Jmeter，web一般使用jmeter，LR
    6. 界面操作：
        * 关于手机端测试，需注意手势、横竖屏切换、多点触控、前后台切换。
    7. 安全测试
        * 安装包是否可以反编译代码、安装包是否签名、权限设置，例如访问通讯录等。
    8. 边界测试：
        * 可用存储空间少，没有SD卡/双SD卡，飞行模式、系统时间有误，第三方依赖等。
    9. 权限测试：
        * 设置某个App是否可以获取该权限，例如是否可访问通讯录、相机等。</code></pre>
</div>


    <div class="post-guide">
        <div class="item left">
            
        </div>
        <div class="item right">
            
              <a href="/2020/06/01/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/">
                面试问答
                <i class="fa fa-angle-right" aria-hidden="true"></i>
              </a>
            
        </div>
    </div>



	<div id="vcomments"></div>


<script>
	
		// 评论
		new Valine({
			av: AV,
			el: '#vcomments',
			notify: false,
			verify: false,
			path: window.location.pathname,
			appId: '',
			appKey: '',
			placeholder: '请输入评论',
			avatar: 'retro',
			recordIP: false
		})
	
	
</script>
	</div>
	<div id="footer">
	<p>
	©2019-<span id="footerYear"></span> 
	<a href="/">Gakki0725</a> 
	
	
		|
		<span id="busuanzi_container_site_pv">
			pv
			<span id="busuanzi_value_site_pv"></span>
		</span>
		|
		<span id="busuanzi_container_site_uv"> 
			uv
			<span id="busuanzi_value_site_uv"></span>
		</span>
	
	<br>
	Theme <a href="//github.com/wujun234/hexo-theme-tree" target="_blank">Tree</a>
	by <a href="//github.com/wujun234" target="_blank">WuJun</a>
	Powered by <a href="//hexo.io" target="_blank">Hexo</a>
	</p>
</div>
<script type="text/javascript"> 
	document.getElementById('footerYear').innerHTML = new Date().getFullYear() + '';
</script>
	<button id="totop-toggle" class="toggle"><i class="fa fa-angle-double-up" aria-hidden="true"></i></button>
</body>
</html>